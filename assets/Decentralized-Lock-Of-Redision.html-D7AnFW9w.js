import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as e}from"./app-BEhkVDlh.js";const t={},p=e(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>随着软件系统的不断迭代，目前越来越多的单体应用已经不再满足当前业务的需求，分布式系统越来越普及（一个应用往往部署到很多台不同的机器上）。为了保证在多机部署环境中，不同机器不同的进程之间 业务操作的安全，分布式锁应运而生。</p><h2 id="必备条件" tabindex="-1"><a class="header-anchor" href="#必备条件"><span>必备条件</span></a></h2><p>为了保证分布式锁的可用，：</p><p>互斥性/排他性：任意时刻，只会有一个”人“能持有锁。</p><p>不会发生死锁：在”甲“持有锁的期间系统崩溃导致没有主动释放锁，也能保证后续 ”乙“能获取锁。-设置超时时间</p><p>加锁和解锁需得同一个”人“：”甲“不能把”乙“加的锁给释放了，隔离性。</p><p>容错性：只要大多数Redis节点正常，”我“就能获取或释放锁。</p><p>可重入：当前线程持有锁后是否可再次进入</p><p>公平性：加锁顺序是否与请求加锁顺序一致，还是随机性</p><h2 id="redission" tabindex="-1"><a class="header-anchor" href="#redission"><span>Redission</span></a></h2><p>支持多种模式：单点模式，总从模式，哨兵模式，集群模式。</p><p>单点模式举例</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>
<span class="token comment">// 1.构造redisson实现分布式锁必要的Config</span>
<span class="token class-name">Config</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">&quot;redis://127.0.0.1:5379&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">&quot;123456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDatabase</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2.构造RedissonClient</span>
<span class="token class-name">RedissonClient</span> redissonClient <span class="token operator">=</span> <span class="token class-name">Redisson</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 3.获取锁对象实例（无法保证是按线程的顺序获取到）</span>
<span class="token class-name">RLock</span> rLock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
   <span class="token doc-comment comment">/**
    *4.尝试获取锁
    * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败
    *leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）
    */</span>
   <span class="token keyword">boolean</span> res <span class="token operator">=</span> rLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>waitTimeout<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//成功获得锁，在这里处理业务</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;aquire lock fail&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
   <span class="token comment">//无论如何, 最后都要解锁</span>
   rLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Lua脚本 加锁脚本</p><p>若锁不存在，则新增锁，并设置锁重入计数为1 设置锁的过期时间</p><p>若锁存在，且唯一标识匹配：则表明当前加锁请求为锁重入请求，锁重入计数+1，并再次设置锁过期时间</p><p>若锁存在，但唯一标识不匹配：则表明锁是被其他线程占用，当前线程无权解锁其他线程的锁，直接返回锁剩余过期时间</p><p>返回nil表明加锁成功，</p><p>解锁脚本</p><p>若锁不存在，则直接广播解锁消息 返回1</p><p>若锁存在，但唯一标识不匹配，表明锁被其他线程占用，返回nil</p><p>若锁存在，且标识匹配，则锁重入计数-1</p><p>锁重入计数-1后如果为0 表明锁已被释放，直接删除锁 并广播解锁消息，去唤醒哪些争抢过锁而目前处于阻塞状态的线程</p><p>锁重入计数-1后还大于- 表明当前线程持有锁还有重入，不能进行删除，可以设置下过期时间</p><p>返回1 表明请求触发了解锁；实际上客户端也并不关心解锁请求的返回值。</p><p>单机模式如果故障就会导致加锁失败。主从模式的话，加锁就只对一个节点加锁，即使通过 sentinel做了高可用，如果主节点故障 在主从切换时可能导致锁丢失的问题。</p>`,27),o=[p];function c(i,l){return a(),s("div",null,o)}const d=n(t,[["render",c],["__file","Decentralized-Lock-Of-Redision.html.vue"]]),k=JSON.parse('{"path":"/article/developer/cloud/Decentralized-Lock-Of-Redision.html","title":"分布式锁解决方案-Redission","lang":"zh-CN","frontmatter":{"title":"分布式锁解决方案-Redission","date":"2024-05-31T00:00:00.000Z","categories":"微服务","tags":["Redission"],"description":"前言 随着软件系统的不断迭代，目前越来越多的单体应用已经不再满足当前业务的需求，分布式系统越来越普及（一个应用往往部署到很多台不同的机器上）。为了保证在多机部署环境中，不同机器不同的进程之间 业务操作的安全，分布式锁应运而生。 必备条件 为了保证分布式锁的可用，： 互斥性/排他性：任意时刻，只会有一个”人“能持有锁。 不会发生死锁：在”甲“持有锁的期间...","head":[["meta",{"property":"og:url","content":"https://lianyp.fun/lyp-blog/article/developer/cloud/Decentralized-Lock-Of-Redision.html"}],["meta",{"property":"og:site_name","content":"小道空间-Vuepress开源轻博客系统"}],["meta",{"property":"og:title","content":"分布式锁解决方案-Redission"}],["meta",{"property":"og:description","content":"前言 随着软件系统的不断迭代，目前越来越多的单体应用已经不再满足当前业务的需求，分布式系统越来越普及（一个应用往往部署到很多台不同的机器上）。为了保证在多机部署环境中，不同机器不同的进程之间 业务操作的安全，分布式锁应运而生。 必备条件 为了保证分布式锁的可用，： 互斥性/排他性：任意时刻，只会有一个”人“能持有锁。 不会发生死锁：在”甲“持有锁的期间..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-31T09:13:50.000Z"}],["meta",{"property":"article:author","content":"梁小道"}],["meta",{"property":"article:tag","content":"Redission"}],["meta",{"property":"article:published_time","content":"2024-05-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-31T09:13:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式锁解决方案-Redission\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-31T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-31T09:13:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"梁小道\\",\\"url\\":\\"https://lianyp.fun\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"必备条件","slug":"必备条件","link":"#必备条件","children":[]},{"level":2,"title":"Redission","slug":"redission","link":"#redission","children":[]}],"git":{"createdTime":1717146830000,"updatedTime":1717146830000,"contributors":[{"name":"liangyp","email":"2267841523@qq.com","commits":1}]},"readingTime":{"minutes":2.98,"words":895},"filePathRelative":"article/developer/cloud/Decentralized-Lock-Of-Redision.md","localizedDate":"2024年5月31日","excerpt":"<h2>前言</h2>\\n<p>随着软件系统的不断迭代，目前越来越多的单体应用已经不再满足当前业务的需求，分布式系统越来越普及（一个应用往往部署到很多台不同的机器上）。为了保证在多机部署环境中，不同机器不同的进程之间 业务操作的安全，分布式锁应运而生。</p>\\n<h2>必备条件</h2>\\n<p>为了保证分布式锁的可用，：</p>\\n<p>互斥性/排他性：任意时刻，只会有一个”人“能持有锁。</p>\\n<p>不会发生死锁：在”甲“持有锁的期间系统崩溃导致没有主动释放锁，也能保证后续 ”乙“能获取锁。-设置超时时间</p>\\n<p>加锁和解锁需得同一个”人“：”甲“不能把”乙“加的锁给释放了，隔离性。</p>","autoDesc":true}');export{d as comp,k as data};
