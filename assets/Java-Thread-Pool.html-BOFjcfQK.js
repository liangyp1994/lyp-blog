import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as n,a as s}from"./app-hwiByNrW.js";const o={},t=s(`<h2 id="threadpoolexecutor" tabindex="-1"><a class="header-anchor" href="#threadpoolexecutor"><span>ThreadPoolExecutor</span></a></h2><p>想要理解Java线程池的原理，我们必须将下面这个构造函数琢磨清楚</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                              <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                              <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                              <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                              <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>corePoolSize 核心线程数 核心线程会一直存活，核心成员一直在，及时没有任何业务需求； 当线程数小于核心线程数，即使有空闲线程，线程池也会创建新的线程进行处理 参数allowCoreThreadTimeout=true（默认false），核心线程会超时关闭</li></ul><p>通常根据系统是 CPU密集或IO密集 按下面这个公式来确定 corePoolSize</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>CPU密集型：corePoolSize <span class="token operator">=</span> CPU核数 + <span class="token number">1</span>

IO密集型：corePoolSize <span class="token operator">=</span> CPU核数 * <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>我的服务器是 2核 内存使用较多 属于 IO密集型，故 corePoolSize=3</p></blockquote><ul><li>maximumPoolSize 最大线程数</li></ul><p>设置最大上限，当线程数=最大线程数，将会执行拒绝策略，默认的话该值为Integer.MAX_VALUE 实际项目中应根据使用场景灵活调整</p><ul><li>keepAliveTime 空闲时长</li><li>workQueue 任务队列</li><li>threadFactory 创建线程的工厂</li><li>handler 拒绝处理器</li></ul><h2 id="任务执行流程" tabindex="-1"><a class="header-anchor" href="#任务执行流程"><span>任务执行流程</span></a></h2><p>用户提交任务 -&gt; 线程池 -&gt; 执行、阻塞 -&gt; 完成</p><ol><li>判断当前运行的任务数量是否超过 <code>corePoolSize</code>,如果不超过 <code>corePoolSize</code> 就创建一个<code>worker</code>直接执行该任务。—— 线程池最开始是没有worker在运行的</li><li>如果正在运行的worker数量超过或者等于corePoolSize,那么就将该任务加入到workQueue队列中去。</li><li>如果workQueue队列满了,也就是offer方法返回false的话，就检查当前运行的worker数量是否小于maximumPoolSize,如果小于就创建一个worker直接执行该任务。</li><li>如果当前运行的worker数量大于等于maximumPoolSize，那么就执行RejectedExecutionHandler来拒绝这个任务的提交。</li></ol>`,13),l=[t];function c(i,r){return n(),a("div",null,l)}const u=e(o,[["render",c],["__file","Java-Thread-Pool.html.vue"]]),m=JSON.parse('{"path":"/article/developer/backend/Java-Thread-Pool.html","title":"Java线程池","lang":"zh-CN","frontmatter":{"title":"Java线程池","date":"2024-05-04T00:00:00.000Z","categories":"后端","description":"ThreadPoolExecutor 想要理解Java线程池的原理，我们必须将下面这个构造函数琢磨清楚 corePoolSize 核心线程数 核心线程会一直存活，核心成员一直在，及时没有任何业务需求； 当线程数小于核心线程数，即使有空闲线程，线程池也会创建新的线程进行处理 参数allowCoreThreadTimeout=true（默认false），核...","head":[["meta",{"property":"og:url","content":"https://lianyp.fun/lyp-blog/article/developer/backend/Java-Thread-Pool.html"}],["meta",{"property":"og:site_name","content":"小道空间-Vuepress开源轻博客系统"}],["meta",{"property":"og:title","content":"Java线程池"}],["meta",{"property":"og:description","content":"ThreadPoolExecutor 想要理解Java线程池的原理，我们必须将下面这个构造函数琢磨清楚 corePoolSize 核心线程数 核心线程会一直存活，核心成员一直在，及时没有任何业务需求； 当线程数小于核心线程数，即使有空闲线程，线程池也会创建新的线程进行处理 参数allowCoreThreadTimeout=true（默认false），核..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-22T05:59:57.000Z"}],["meta",{"property":"article:author","content":"梁小道"}],["meta",{"property":"article:published_time","content":"2024-05-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-22T05:59:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java线程池\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-04T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-22T05:59:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"梁小道\\",\\"url\\":\\"https://lianyp.fun\\"}]}"]]},"headers":[{"level":2,"title":"ThreadPoolExecutor","slug":"threadpoolexecutor","link":"#threadpoolexecutor","children":[]},{"level":2,"title":"任务执行流程","slug":"任务执行流程","link":"#任务执行流程","children":[]}],"git":{"createdTime":1716002958000,"updatedTime":1716357597000,"contributors":[{"name":"liangyp","email":"2267841523@qq.com","commits":3}]},"readingTime":{"minutes":1.57,"words":472},"filePathRelative":"article/developer/backend/Java-Thread-Pool.md","localizedDate":"2024年5月4日","excerpt":"<h2>ThreadPoolExecutor</h2>\\n<p>想要理解Java线程池的原理，我们必须将下面这个构造函数琢磨清楚</p>\\n<div class=\\"language-java\\" data-ext=\\"java\\" data-title=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">public</span> <span class=\\"token class-name\\">ThreadPoolExecutor</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">int</span> corePoolSize<span class=\\"token punctuation\\">,</span>\\n                              <span class=\\"token keyword\\">int</span> maximumPoolSize<span class=\\"token punctuation\\">,</span>\\n                              <span class=\\"token keyword\\">long</span> keepAliveTime<span class=\\"token punctuation\\">,</span>\\n                              <span class=\\"token class-name\\">TimeUnit</span> unit<span class=\\"token punctuation\\">,</span>\\n                              <span class=\\"token class-name\\">BlockingQueue</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">Runnable</span><span class=\\"token punctuation\\">&gt;</span></span> workQueue<span class=\\"token punctuation\\">,</span>\\n                              <span class=\\"token class-name\\">ThreadFactory</span> threadFactory<span class=\\"token punctuation\\">,</span>\\n                              <span class=\\"token class-name\\">RejectedExecutionHandler</span> handler<span class=\\"token punctuation\\">)</span>\\n\\n</code></pre></div>","autoDesc":true}');export{u as comp,m as data};
