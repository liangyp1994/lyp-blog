import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as n,a as s}from"./app-BEhkVDlh.js";const t={},o=s(`<p>正如 “连接池” “用户池” 等概念一样，“池” 通常代表的就是一个容器，负责放置相关的事物。那么线程池当然就是放置了大量线程的一个空间容器。线程池的创建主要目的是为了减少 创建和销毁线程的这个资源损耗，通过线程池实现线程的复用，当然也方便对线程的管理和监控。以上介绍了什么是线程池，目的是什么，都有哪些优点。接下来看看在Java中如何使用线程池</p><h2 id="threadpoolexecutor" tabindex="-1"><a class="header-anchor" href="#threadpoolexecutor"><span>ThreadPoolExecutor</span></a></h2><p>想要理解Java线程池的原理，我们必须将下面这个构造函数琢磨清楚</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                              <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                              <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                              <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                              <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>corePoolSize:核心线程数 maximumPoolSize:最大线程数 keepAliveTime:线程空闲时存活时间 unit:单位 workQueue:工作队列 threadFactory:线程创建工厂 handler:拒绝策略</p></blockquote><ul><li>corePoolSize 核心线程数 核心线程会一直存活，核心成员一直在，及时没有任何业务需求； 当线程数小于核心线程数，即使有空闲线程，线程池也会创建新的线程进行处理 参数allowCoreThreadTimeout=true（默认false），核心线程会超时关闭</li></ul><p>通常根据系统是 CPU密集或IO密集 按下面这个公式来确定 corePoolSize</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>CPU密集型：corePoolSize <span class="token operator">=</span> CPU核数 + <span class="token number">1</span>

IO密集型：corePoolSize <span class="token operator">=</span> CPU核数 * <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>我的服务器是 2核 内存使用较多 属于 IO密集型，故 corePoolSize=3</p></blockquote><ul><li>maximumPoolSize 最大线程数</li></ul><p>设置最大上限，当线程数=最大线程数，将会执行拒绝策略，默认的话该值为Integer.MAX_VALUE 实际项目中应根据使用场景灵活调整</p><ul><li>keepAliveTime 空闲时长</li><li>workQueue 任务队列</li><li>threadFactory 创建线程的工厂</li><li>handler 拒绝处理器</li></ul><h2 id="任务执行流程" tabindex="-1"><a class="header-anchor" href="#任务执行流程"><span>任务执行流程</span></a></h2><p>用户提交任务 -&gt; 线程池 -&gt; 执行、阻塞 -&gt; 完成</p><ol><li>判断当前运行的任务数量是否超过 <code>corePoolSize</code>,如果不超过 <code>corePoolSize</code> 就创建一个<code>worker</code>直接执行该任务。—— 线程池最开始是没有worker在运行的</li><li>如果正在运行的worker数量超过或者等于corePoolSize,那么就将该任务加入到workQueue队列中去。</li><li>如果workQueue队列满了,也就是offer方法返回false的话，就检查当前运行的worker数量是否小于maximumPoolSize,如果小于就创建一个worker直接执行该任务。</li><li>如果当前运行的worker数量大于等于maximumPoolSize，那么就执行RejectedExecutionHandler来拒绝这个任务的提交。</li></ol><h2 id="线程池的状态" tabindex="-1"><a class="header-anchor" href="#线程池的状态"><span>线程池的状态</span></a></h2><ul><li><p>RUNNING运行状态：可以接收新任务以及处理队列中的任务</p></li><li><p>SHUTDOWN: 不接收新任务但会继续处理队列中已有的任务</p></li><li><p>STOP：不接收新任务且挂起不再处理队列中的任务，还会中断正在处理的任务</p></li><li><p>TIDYING: 所有任务已经终止，有效线程数为0，会转为tidying状态，并调用 terminate 钩子</p></li><li><p>TERMINATE：terminate运行完成。</p></li></ul><h2 id="线程池的拒绝策略" tabindex="-1"><a class="header-anchor" href="#线程池的拒绝策略"><span>线程池的拒绝策略</span></a></h2><ul><li><p>abort：中止，放弃：将会抛出异常 由外部根据异常自行做决定</p></li><li><p>discard：丢弃：直接丢弃任务，不做任何其他动作</p></li><li><p>discardOldest：同上，但是它丢弃的是阻塞队列中的任务</p></li><li><p>callRuns: 让调用线程去执行任务</p></li></ul>`,19),l=[o];function i(p,c){return n(),a("div",null,l)}const u=e(t,[["render",i],["__file","Java-Thread-Pool.html.vue"]]),m=JSON.parse('{"path":"/article/developer/backend/Java-Thread-Pool.html","title":"Java线程池","lang":"zh-CN","frontmatter":{"title":"Java线程池","date":"2024-05-04T00:00:00.000Z","categories":"后端","tags":["并发编程"],"description":"正如 “连接池” “用户池” 等概念一样，“池” 通常代表的就是一个容器，负责放置相关的事物。那么线程池当然就是放置了大量线程的一个空间容器。线程池的创建主要目的是为了减少 创建和销毁线程的这个资源损耗，通过线程池实现线程的复用，当然也方便对线程的管理和监控。以上介绍了什么是线程池，目的是什么，都有哪些优点。接下来看看在Java中如何使用线程池 Thr...","head":[["meta",{"property":"og:url","content":"https://lianyp.fun/lyp-blog/article/developer/backend/Java-Thread-Pool.html"}],["meta",{"property":"og:site_name","content":"小道空间-Vuepress开源轻博客系统"}],["meta",{"property":"og:title","content":"Java线程池"}],["meta",{"property":"og:description","content":"正如 “连接池” “用户池” 等概念一样，“池” 通常代表的就是一个容器，负责放置相关的事物。那么线程池当然就是放置了大量线程的一个空间容器。线程池的创建主要目的是为了减少 创建和销毁线程的这个资源损耗，通过线程池实现线程的复用，当然也方便对线程的管理和监控。以上介绍了什么是线程池，目的是什么，都有哪些优点。接下来看看在Java中如何使用线程池 Thr..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-31T09:13:50.000Z"}],["meta",{"property":"article:author","content":"梁小道"}],["meta",{"property":"article:tag","content":"并发编程"}],["meta",{"property":"article:published_time","content":"2024-05-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-31T09:13:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java线程池\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-04T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-31T09:13:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"梁小道\\",\\"url\\":\\"https://lianyp.fun\\"}]}"]]},"headers":[{"level":2,"title":"ThreadPoolExecutor","slug":"threadpoolexecutor","link":"#threadpoolexecutor","children":[]},{"level":2,"title":"任务执行流程","slug":"任务执行流程","link":"#任务执行流程","children":[]},{"level":2,"title":"线程池的状态","slug":"线程池的状态","link":"#线程池的状态","children":[]},{"level":2,"title":"线程池的拒绝策略","slug":"线程池的拒绝策略","link":"#线程池的拒绝策略","children":[]}],"git":{"createdTime":1716002958000,"updatedTime":1717146830000,"contributors":[{"name":"liangyp","email":"2267841523@qq.com","commits":4}]},"readingTime":{"minutes":2.86,"words":859},"filePathRelative":"article/developer/backend/Java-Thread-Pool.md","localizedDate":"2024年5月4日","excerpt":"<p>正如 “连接池” “用户池” 等概念一样，“池” 通常代表的就是一个容器，负责放置相关的事物。那么线程池当然就是放置了大量线程的一个空间容器。线程池的创建主要目的是为了减少 创建和销毁线程的这个资源损耗，通过线程池实现线程的复用，当然也方便对线程的管理和监控。以上介绍了什么是线程池，目的是什么，都有哪些优点。接下来看看在Java中如何使用线程池</p>\\n<h2>ThreadPoolExecutor</h2>\\n<p>想要理解Java线程池的原理，我们必须将下面这个构造函数琢磨清楚</p>\\n<div class=\\"language-java\\" data-ext=\\"java\\" data-title=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">public</span> <span class=\\"token class-name\\">ThreadPoolExecutor</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">int</span> corePoolSize<span class=\\"token punctuation\\">,</span>\\n                              <span class=\\"token keyword\\">int</span> maximumPoolSize<span class=\\"token punctuation\\">,</span>\\n                              <span class=\\"token keyword\\">long</span> keepAliveTime<span class=\\"token punctuation\\">,</span>\\n                              <span class=\\"token class-name\\">TimeUnit</span> unit<span class=\\"token punctuation\\">,</span>\\n                              <span class=\\"token class-name\\">BlockingQueue</span><span class=\\"token generics\\"><span class=\\"token punctuation\\">&lt;</span><span class=\\"token class-name\\">Runnable</span><span class=\\"token punctuation\\">&gt;</span></span> workQueue<span class=\\"token punctuation\\">,</span>\\n                              <span class=\\"token class-name\\">ThreadFactory</span> threadFactory<span class=\\"token punctuation\\">,</span>\\n                              <span class=\\"token class-name\\">RejectedExecutionHandler</span> handler<span class=\\"token punctuation\\">)</span>\\n\\n</code></pre></div>","autoDesc":true}');export{u as comp,m as data};
