import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as a,a as l}from"./app-Co8UXNfU.js";const n={},i=l(`<h2 id="平衡二叉树" tabindex="-1"><a class="header-anchor" href="#平衡二叉树"><span>平衡二叉树</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>|--- 查找二叉树
    |--- 平衡二叉树
    |--- 完全二叉树
    |--- 满二叉树
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>左子树和右子树的<strong>高度</strong>差不超过1，它的一个重要应用就是AVL树，一种自平衡的二叉搜索树。</p><p>思考：</p><ol><li>为什么要减少左右子树的高度差呢？我们先假设一个最糟糕的情况那就是只有右子树，那结构是不是就退化成为了链表的结构了。这会导致查找的效率直线下降。</li><li>AVL树 是 为了满足平衡二叉树 通过<strong>左旋 右旋</strong>这两个动作实现自平衡的一种方式</li></ol><h3 id="左旋和右旋" tabindex="-1"><a class="header-anchor" href="#左旋和右旋"><span>左旋和右旋</span></a></h3><p>左旋和右旋都是树的一种旋转操作，左旋操作的作用是将当前节点的右子节点提升为当前节点的父节点，同时当前节点成为其右子节点的左子节点。右旋操作的作用是将当前节点的左子节点提升为当前节点的父节点，同时当前节点成为其左子节点的右子节点。 比如右儿子是红色的，左儿子是黑色的，需要进行左旋来改变结构。比如左儿子是红色的，右儿子是红色的，需要进行右旋来改变结构。</p><h2 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span>红黑树</span></a></h2><p>红黑树的性质</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点（NULL）是黑色的。</li><li>每个叶子节点（NIL 节点）是黑色的。</li><li>如果一个节点是红色，那么其子节点不能同时为红色。</li><li>从任意节点到其每个叶子节点的简单路径包含相同数量的黑色节点。</li></ol><blockquote><p>先背下来再去理解，前面三点很容易理解，最重要的是把后面两点去理解清楚。实话说每次学习数据结构的时候总是头疼的，因为很多定义，性质，你只能去记住，或者是花时间实践，多使用。</p></blockquote>`,11),o=[i];function r(s,c){return a(),t("div",null,o)}const m=e(n,[["render",r],["__file","Hello-DS.html.vue"]]),h=JSON.parse('{"path":"/java/Java-Guide/Hello-DS.html","title":"数据结构","lang":"zh-CN","frontmatter":{"title":"数据结构","article":false,"order":9,"description":"平衡二叉树 左子树和右子树的高度差不超过1，它的一个重要应用就是AVL树，一种自平衡的二叉搜索树。 思考： 为什么要减少左右子树的高度差呢？我们先假设一个最糟糕的情况那就是只有右子树，那结构是不是就退化成为了链表的结构了。这会导致查找的效率直线下降。 AVL树 是 为了满足平衡二叉树 通过左旋 右旋这两个动作实现自平衡的一种方式 左旋和右旋 左旋和右旋...","head":[["meta",{"property":"og:url","content":"https://lianyp.fun/lyp-blog/java/Java-Guide/Hello-DS.html"}],["meta",{"property":"og:site_name","content":"小道空间-Vuepress开源轻博客系统"}],["meta",{"property":"og:title","content":"数据结构"}],["meta",{"property":"og:description","content":"平衡二叉树 左子树和右子树的高度差不超过1，它的一个重要应用就是AVL树，一种自平衡的二叉搜索树。 思考： 为什么要减少左右子树的高度差呢？我们先假设一个最糟糕的情况那就是只有右子树，那结构是不是就退化成为了链表的结构了。这会导致查找的效率直线下降。 AVL树 是 为了满足平衡二叉树 通过左旋 右旋这两个动作实现自平衡的一种方式 左旋和右旋 左旋和右旋..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-29T08:03:02.000Z"}],["meta",{"property":"article:author","content":"梁小道"}],["meta",{"property":"article:modified_time","content":"2024-05-29T08:03:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"数据结构\\",\\"description\\":\\"平衡二叉树 左子树和右子树的高度差不超过1，它的一个重要应用就是AVL树，一种自平衡的二叉搜索树。 思考： 为什么要减少左右子树的高度差呢？我们先假设一个最糟糕的情况那就是只有右子树，那结构是不是就退化成为了链表的结构了。这会导致查找的效率直线下降。 AVL树 是 为了满足平衡二叉树 通过左旋 右旋这两个动作实现自平衡的一种方式 左旋和右旋 左旋和右旋...\\"}"]]},"headers":[{"level":2,"title":"平衡二叉树","slug":"平衡二叉树","link":"#平衡二叉树","children":[{"level":3,"title":"左旋和右旋","slug":"左旋和右旋","link":"#左旋和右旋","children":[]}]},{"level":2,"title":"红黑树","slug":"红黑树","link":"#红黑树","children":[]}],"git":{"createdTime":1716969782000,"updatedTime":1716969782000,"contributors":[{"name":"liangyp","email":"2267841523@qq.com","commits":1}]},"readingTime":{"minutes":1.73,"words":520},"filePathRelative":"java/Java-Guide/Hello-DS.md","localizedDate":"2024年5月29日","excerpt":"<h2>平衡二叉树</h2>\\n<div class=\\"language-text\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"language-text\\"><code>|--- 查找二叉树\\n    |--- 平衡二叉树\\n    |--- 完全二叉树\\n    |--- 满二叉树\\n</code></pre></div><p>左子树和右子树的<strong>高度</strong>差不超过1，它的一个重要应用就是AVL树，一种自平衡的二叉搜索树。</p>\\n<p>思考：</p>\\n<ol>\\n<li>为什么要减少左右子树的高度差呢？我们先假设一个最糟糕的情况那就是只有右子树，那结构是不是就退化成为了链表的结构了。这会导致查找的效率直线下降。</li>\\n<li>AVL树 是 为了满足平衡二叉树 通过<strong>左旋 右旋</strong>这两个动作实现自平衡的一种方式</li>\\n</ol>","autoDesc":true}');export{m as comp,h as data};
