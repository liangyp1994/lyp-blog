import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as t,a as n}from"./app-Co8UXNfU.js";const r={},i=n(`<h2 id="协程和线程" tabindex="-1"><a class="header-anchor" href="#协程和线程"><span>协程和线程</span></a></h2><p>协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。 线程：一个线程上可以跑多个协程，协程是轻量级的线程。</p><h2 id="goroutine" tabindex="-1"><a class="header-anchor" href="#goroutine"><span>goroutine</span></a></h2><p>goroutine 官方实现的“线程池” ，奉行通过通信来进行内存共享，而不是共享内存来进行通信......</p><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p><p>Go语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。</p><h3 id="使用goroutine" tabindex="-1"><a class="header-anchor" href="#使用goroutine"><span>使用goroutine</span></a></h3><p>Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。</p><p>一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p><h4 id="启动单个goroutine" tabindex="-1"><a class="header-anchor" href="#启动单个goroutine"><span>启动单个goroutine</span></a></h4><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字。</p><p>举个例子如下：</p><p>func hello() { fmt.Println(&quot;Hello Goroutine!&quot;) } func main() { hello() fmt.Println(&quot;main goroutine done!&quot;) }</p><p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完Hello Goroutine!后打印main goroutine done!。</p><p>接下来我们在调用hello函数前面加上关键字go，也就是启动一个goroutine去执行hello这个函数。</p><p>func main() { go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(&quot;main goroutine done!&quot;) }</p><p>这一次的执行结果只打印了main goroutine done!，并没有打印Hello Goroutine!。为什么呢？</p><p>在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。</p><p>当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p><p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是time.Sleep了。</p><p>func main() { go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(&quot;main goroutine done!&quot;) time.Sleep(time.Second) }</p><p>执行上面的代码你会发现，这一次先打印main goroutine done!，然后紧接着打印Hello Goroutine!。</p><p>首先为什么会先打印main goroutine done!是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。</p><h4 id="启动多个goroutine" tabindex="-1"><a class="header-anchor" href="#启动多个goroutine"><span>启动多个goroutine</span></a></h4><p>在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步）</p><p>var wg sync.WaitGroup</p><p>func hello(i int) { defer wg.Done() // goroutine结束就登记-1 fmt.Println(&quot;Hello Goroutine!&quot;, i) } func main() {</p><pre><code>for i := 0; i &lt; 10; i++ {
    wg.Add(1) // 启动一个goroutine就登记+1
    go hello(i)
}
wg.Wait() // 等待所有登记的goroutine都结束
</code></pre><p>}</p><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。</p><p>如果主协程退出了，其他任务还执行吗（运行下面的代码测试一下吧）</p><h3 id="goroutine与线程" tabindex="-1"><a class="header-anchor" href="#goroutine与线程"><span>goroutine与线程</span></a></h3><h4 id="可增长的栈" tabindex="-1"><a class="header-anchor" href="#可增长的栈"><span>可增长的栈</span></a></h4><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。</p><h3 id="goroutine调度" tabindex="-1"><a class="header-anchor" href="#goroutine调度"><span>goroutine调度</span></a></h3><p>GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p><p>1.G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。 2.P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。 3.M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</p><p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p><p>P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>`,41),a=[i];function u(p,l){return t(),e("div",null,a)}const h=o(r,[["render",u],["__file","Concurrent-For-Golang.html.vue"]]),d=JSON.parse('{"path":"/article/developer/backend/Concurrent-For-Golang.html","title":"Go语言下的多线程","lang":"zh-CN","frontmatter":{"title":"Go语言下的多线程","date":"2024-05-31T00:00:00.000Z","description":"协程和线程 协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。 线程：一个线程上可以跑多个协程，协程是轻量级的线程。 goroutine goroutine 官方实现的“线程池” ，奉行通过通信来进行内存共享，而不是共享内存来进行通信...... 在java/c++中我们要实现并发编程的...","head":[["meta",{"property":"og:url","content":"https://lianyp.fun/lyp-blog/article/developer/backend/Concurrent-For-Golang.html"}],["meta",{"property":"og:site_name","content":"小道空间-Vuepress开源轻博客系统"}],["meta",{"property":"og:title","content":"Go语言下的多线程"}],["meta",{"property":"og:description","content":"协程和线程 协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。 线程：一个线程上可以跑多个协程，协程是轻量级的线程。 goroutine goroutine 官方实现的“线程池” ，奉行通过通信来进行内存共享，而不是共享内存来进行通信...... 在java/c++中我们要实现并发编程的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-31T09:13:50.000Z"}],["meta",{"property":"article:author","content":"梁小道"}],["meta",{"property":"article:published_time","content":"2024-05-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-31T09:13:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go语言下的多线程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-31T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-31T09:13:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"梁小道\\",\\"url\\":\\"https://lianyp.fun\\"}]}"]]},"headers":[{"level":2,"title":"协程和线程","slug":"协程和线程","link":"#协程和线程","children":[]},{"level":2,"title":"goroutine","slug":"goroutine","link":"#goroutine","children":[{"level":3,"title":"使用goroutine","slug":"使用goroutine","link":"#使用goroutine","children":[]},{"level":3,"title":"goroutine与线程","slug":"goroutine与线程","link":"#goroutine与线程","children":[]},{"level":3,"title":"goroutine调度","slug":"goroutine调度","link":"#goroutine调度","children":[]}]}],"git":{"createdTime":1717146830000,"updatedTime":1717146830000,"contributors":[{"name":"liangyp","email":"2267841523@qq.com","commits":1}]},"readingTime":{"minutes":6.26,"words":1879},"filePathRelative":"article/developer/backend/Concurrent-For-Golang.md","localizedDate":"2024年5月31日","excerpt":"<h2>协程和线程</h2>\\n<p>协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。 线程：一个线程上可以跑多个协程，协程是轻量级的线程。</p>\\n<h2>goroutine</h2>\\n<p>goroutine 官方实现的“线程池” ，奉行通过通信来进行内存共享，而不是共享内存来进行通信......</p>\\n<p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p>","autoDesc":true}');export{h as comp,d as data};
