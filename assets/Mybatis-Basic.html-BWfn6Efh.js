import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as t,a as s}from"./app-Co8UXNfU.js";const l={},p=s('<h2 id="和-的区别" tabindex="-1"><a class="header-anchor" href="#和-的区别"><span>#{}和 ${}的区别</span></a></h2><p>变量占位符${}，他可以用于文本替换，一般会用在 按某字段排序，将字段名传递进去实现 原样文本替换。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">order</span> <span class="token keyword">by</span> ${columName}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>#{} 是参数占位符，Mybatis将sql中的#{} 替换成 ? 号，随后在执行是通过使用参数设置方法将参数值依次赋给 ? 号。如果是 对象则使用反射获取对象的属性值后在进行赋值</p></blockquote><h2 id="mapper接口的工作原理是什么" tabindex="-1"><a class="header-anchor" href="#mapper接口的工作原理是什么"><span>Mapper接口的工作原理是什么？</span></a></h2><p>通常在项目中我们会一个Mapper接口对应一个xml文件，其中xml文件的namespace的值为 mapper接口的全限命名，接口中的各个不同的方法则对应xml文件里 MappedStatement的id值，接口方法中参数传递到sql中</p><p>在Mybatis中 ，select， update， delete，insert 这些标签都会被解析为MappedStatement对象，当调用mapper接口中的方法，会以 接口全限命名+方法名作为Key，定位xml文件中的 MappedStatement。</p><p>注意 Mybatis中 Mapper接口的方法可以重载，但是xml中的ID不允许重复，即我们可以定义两个同名的方法，但调用xml中同一个 MappedStatement，虽然看着没这个必要，但要知道并不会报错。</p><p>Mapper接口的工作原理，是通过JDK动态代理来为接口生成代理proxy对象，代理对象转而去执行MappedStatement所代表的sql，然后将结果返回。</p><h3 id="mybatis是如何进行分页的" tabindex="-1"><a class="header-anchor" href="#mybatis是如何进行分页的"><span>Mybatis是如何进行分页的？</span></a></h3><p>使用到了 RowBounds对象</p><p>private final int offset; private final int limit;</p><p>针对ResultSet结果集执行的内存分页，非物理分页，</p><p>可以在sql中直接通过书写带有物理分页的参数来分页，也可以使用分页插件来完成物理分页</p><p>分页插件的原理是是使用Mybatis提供的插件接口实现拦截方法中对待执行的sql进行重写，根据dialect方言，添加对应的物理分页语句和参数</p><h3 id="mybatis插件" tabindex="-1"><a class="header-anchor" href="#mybatis插件"><span>Mybatis插件</span></a></h3><p>针对 ParameterHandler、ResultSetHandler、Statementhandler、Executor这四种接口我们可以自己编写插件，Mybatis是通过JDK动态代理，为需要拦截的接口生成代理对象以实现接口方法的拦截，随后在执行上面提到的接口对象的方法是，就会进入拦截，然后我们就可以在拦截的方法里面进行复写，</p><p>具体做法：通过实现Mybatis的Interceptor接口并且复写 intercept() 方法，然后在给插件编写注解， 指定要拦截哪一个接口的哪些方法即可，注意还要在配置文件中配置编写的插件，注册进去。</p><p>Mybatis在执行批量插入，能返回主键列表吗？</p><p>能</p><h3 id="mybatis动态sql" tabindex="-1"><a class="header-anchor" href="#mybatis动态sql"><span>Mybatis动态sql</span></a></h3><p>通过标签的形式进行动态sql拼接，逻辑判断，执行原理为：使用OGNL从sql参数对象中计算表达式的值，从而实现动态拼接，实现动态sql的功能。</p><h3 id="mybatis的返回结果" tabindex="-1"><a class="header-anchor" href="#mybatis的返回结果"><span>Mybatis的返回结果</span></a></h3><p>第一种是通过ResultMap，在其中定义了列与对象属性之间的映射关系。第二种是是哟个sql列的别名功能，将名字书写为对象属性的名字。对应了属性名自然后续就能通过反射创建java对象，同时也就给对新的属性进行赋值，当然找不到属性的话是无法完成赋值，但不会报错，所以如果你的返回结果中某个字段始终为空，可以看看是否映射成功。</p><h3 id="mybatis的延迟加载" tabindex="-1"><a class="header-anchor" href="#mybatis的延迟加载"><span>Mybatis的延迟加载</span></a></h3><p>仅支持 association关联对象和 collection关联集合对象的延迟加载。在Mybatis配置中可以配置是否启用延迟加载</p><p>原理是 ，使用CGLIB创建目标对象的代理对象，当调用目标方法是，进入拦截器，然后invoke在执行时会发现该结果对象的 对象属性(association) 或 集合属性(collection) 为null值，这时就会单独发送事先保存好的查询该&quot;对象/集合&quot;的sql，将其查询出来，然后调用set方法，进行赋值，</p><p>举个例子：查询对象user，其中有个属性为 roles列表，当我去获取某一个角色名称时候发现 roles为null，此时才会去查询roles的值，所以说是延迟加载</p><h3 id="mybatis中如何执行批处理" tabindex="-1"><a class="header-anchor" href="#mybatis中如何执行批处理"><span>Mybatis中如何执行批处理</span></a></h3><p>使用BatchExecutor完成</p><h3 id="mybatis有哪些执行器-区别是什么" tabindex="-1"><a class="header-anchor" href="#mybatis有哪些执行器-区别是什么"><span>Mybatis有哪些执行器，区别是什么?</span></a></h3><p>有三种基本的执行器，分别是</p><p>SimpleExecutor：每执行一次update或select，就开启了一个Statement对象，用完就关。</p><p>ReuseExecutor：执行update或select，以sql为key查找Statement对象，存在就使用，不存在就创建，用完后 不会关闭，而是放在Map里面，供下次使用。</p><p>BatchExecutor：执行update，将所有sql都添加到批处理中，等待统一执行，它缓存了多个Statement对象，每个Statement对象都是添加到批处理完毕后，等待逐一执行批处理，与JDBC的批处理相同。</p><p>注意，这些特点，都严格限制在SqlSession生命周期内。</p><h3 id="是否可以映射枚举" tabindex="-1"><a class="header-anchor" href="#是否可以映射枚举"><span>是否可以映射枚举</span></a></h3><p>可以，通过自定义 TypeHandler,实现相关方法，它完成了从javaType到jdbcType的相互转换</p><h3 id="mybatis-xml文件的标签顺序" tabindex="-1"><a class="header-anchor" href="#mybatis-xml文件的标签顺序"><span>mybatis xml文件的标签顺序</span></a></h3><p>虽然解析过程是按顺序的，但是如果出现A标签里面引用了B便签，并不一定要将B标签写在A标签前面，因为Mybatis会现将A标签标为为解析状态，继续解析剩余的标签，等到后续在重新解析为解析的标签。</p><h3 id="xml映射文件和内部数据结构的映射关系" tabindex="-1"><a class="header-anchor" href="#xml映射文件和内部数据结构的映射关系"><span>xml映射文件和内部数据结构的映射关系</span></a></h3><p><code>&lt;parameterMap&gt;</code> 解析为 ParameterMap对象，其内的子元素会被解析为 ParameterMapping对象。</p><p><code>&lt;resultMap&gt;</code> 解析为 ResultMap 对象，其内的子元素被解析为ResultMapping对象</p><p>每一个 <code>&lt;select&gt; &lt;insert&gt; &lt;update&gt; &lt;delete&gt;</code> 标签会被解析为 <code>MappedStatement</code> 对象，</p><p>标签内的sql被解析为 BoundSql 对象</p>',45),i=[p];function n(r,o){return t(),a("div",null,i)}const m=e(l,[["render",n],["__file","Mybatis-Basic.html.vue"]]),y=JSON.parse('{"path":"/article/developer/backend/Mybatis-Basic.html","title":"Mybatis基础","lang":"zh-CN","frontmatter":{"title":"Mybatis基础","date":"2024-05-31T00:00:00.000Z","categories":"后端","tags":["Mybatis"],"description":"#{}和 ${}的区别 变量占位符${}，他可以用于文本替换，一般会用在 按某字段排序，将字段名传递进去实现 原样文本替换。 #{} 是参数占位符，Mybatis将sql中的#{} 替换成 ? 号，随后在执行是通过使用参数设置方法将参数值依次赋给 ? 号。如果是 对象则使用反射获取对象的属性值后在进行赋值 Mapper接口的工作原理是什么？ 通常在项目...","head":[["meta",{"property":"og:url","content":"https://lianyp.fun/lyp-blog/article/developer/backend/Mybatis-Basic.html"}],["meta",{"property":"og:site_name","content":"小道空间-Vuepress开源轻博客系统"}],["meta",{"property":"og:title","content":"Mybatis基础"}],["meta",{"property":"og:description","content":"#{}和 ${}的区别 变量占位符${}，他可以用于文本替换，一般会用在 按某字段排序，将字段名传递进去实现 原样文本替换。 #{} 是参数占位符，Mybatis将sql中的#{} 替换成 ? 号，随后在执行是通过使用参数设置方法将参数值依次赋给 ? 号。如果是 对象则使用反射获取对象的属性值后在进行赋值 Mapper接口的工作原理是什么？ 通常在项目..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-31T09:13:50.000Z"}],["meta",{"property":"article:author","content":"梁小道"}],["meta",{"property":"article:tag","content":"Mybatis"}],["meta",{"property":"article:published_time","content":"2024-05-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-31T09:13:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Mybatis基础\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-31T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-31T09:13:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"梁小道\\",\\"url\\":\\"https://lianyp.fun\\"}]}"]]},"headers":[{"level":2,"title":"#{}和 ${}的区别","slug":"和-的区别","link":"#和-的区别","children":[]},{"level":2,"title":"Mapper接口的工作原理是什么？","slug":"mapper接口的工作原理是什么","link":"#mapper接口的工作原理是什么","children":[{"level":3,"title":"Mybatis是如何进行分页的？","slug":"mybatis是如何进行分页的","link":"#mybatis是如何进行分页的","children":[]},{"level":3,"title":"Mybatis插件","slug":"mybatis插件","link":"#mybatis插件","children":[]},{"level":3,"title":"Mybatis动态sql","slug":"mybatis动态sql","link":"#mybatis动态sql","children":[]},{"level":3,"title":"Mybatis的返回结果","slug":"mybatis的返回结果","link":"#mybatis的返回结果","children":[]},{"level":3,"title":"Mybatis的延迟加载","slug":"mybatis的延迟加载","link":"#mybatis的延迟加载","children":[]},{"level":3,"title":"Mybatis中如何执行批处理","slug":"mybatis中如何执行批处理","link":"#mybatis中如何执行批处理","children":[]},{"level":3,"title":"Mybatis有哪些执行器，区别是什么?","slug":"mybatis有哪些执行器-区别是什么","link":"#mybatis有哪些执行器-区别是什么","children":[]},{"level":3,"title":"是否可以映射枚举","slug":"是否可以映射枚举","link":"#是否可以映射枚举","children":[]},{"level":3,"title":"mybatis xml文件的标签顺序","slug":"mybatis-xml文件的标签顺序","link":"#mybatis-xml文件的标签顺序","children":[]},{"level":3,"title":"xml映射文件和内部数据结构的映射关系","slug":"xml映射文件和内部数据结构的映射关系","link":"#xml映射文件和内部数据结构的映射关系","children":[]}]}],"git":{"createdTime":1717146830000,"updatedTime":1717146830000,"contributors":[{"name":"liangyp","email":"2267841523@qq.com","commits":1}]},"readingTime":{"minutes":5.03,"words":1508},"filePathRelative":"article/developer/backend/Mybatis-Basic.md","localizedDate":"2024年5月31日","excerpt":"<h2>#{}和 ${}的区别</h2>\\n<p>变量占位符${}，他可以用于文本替换，一般会用在 按某字段排序，将字段名传递进去实现 原样文本替换。</p>\\n<div class=\\"language-sql\\" data-ext=\\"sql\\" data-title=\\"sql\\"><pre class=\\"language-sql\\"><code><span class=\\"token keyword\\">select</span> <span class=\\"token operator\\">*</span> <span class=\\"token keyword\\">from</span> <span class=\\"token keyword\\">user</span> <span class=\\"token keyword\\">order</span> <span class=\\"token keyword\\">by</span> ${columName}\\n</code></pre></div>","autoDesc":true}');export{m as comp,y as data};
