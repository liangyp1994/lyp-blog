import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as l,a as i}from"./app-DoPi1R1y.js";const a={},o=i(`<h2 id="什么是线程池" tabindex="-1"><a class="header-anchor" href="#什么是线程池"><span>什么是线程池</span></a></h2><p>线程池是对于线程而言的一种池化技术，通过线程池实现了对线程的管理，避免频繁创建和销毁线程导致的损耗。本来正常应该销毁的线程因为线程池这个技术现在不会直接销毁，可能会等待一段时间又去完成一个新的任务，这样达到了线程复用，过程中该线程仅仅是等待了一段时间，状态进行了相关的变化而已。</p><p>如果用过JVM调优，应该看到过当我们启用JVM之后是可以看到程序当前使用的线程数量的，而对于系统来说线程也是需要耗费资源的，线程的创建和销毁涉及到操作系统底层到用户层的切换，所以属于一个偏重的操作。很多任务执行过程特别短，但是呢，数量多，这时候通过线程池就是非常合适的。</p><p>优势：</p><ul><li><p>统一管理</p></li><li><p>复用</p></li></ul><h3 id="线程池的使用" tabindex="-1"><a class="header-anchor" href="#线程池的使用"><span>线程池的使用</span></a></h3><p>结合实际场景配置线程池的参数：</p><ul><li>核心线程数</li></ul><p>核心线程基本不会被销毁，可以通过配置 allowCoreThreadTimeout=true 让核心线程超时关闭。</p><ol><li>如果是执行CPU密集型的任务，可以考虑设置较少的核心线程数；如果是执行I/O密集型的任务，可以考虑设置较多的核心线程数。IO是需要等待的，CPU会摸鱼，可以增加线程数让它不要那么闲</li></ol><p>通用公式：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>CPU密集型：corePoolSize = CPU核数 + 1
IO密集型：corePoolSize = CPU核数 * 2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>最大线程数</li></ul><p>不要使用默认的值，避免资源耗尽和系统崩溃，根据实际系统的CPU和内存资源来确定，并且在程序运行过程中随着监控的情况去适当的修改参数</p><ul><li>阻塞队列</li></ul><p>当有新的任务进来，通过判断决定是否需要创建线程去执行该任务亦或是进入到阻塞队列。</p><ol><li><p>ArrayBlockingQueue 基于数组的有界阻塞队列 , 需要 指定阻塞队列大小</p></li><li><p>LinkedBlockingQueue 基于链表的阻塞队列，有界（但大小默认值为<br> integer.MAX_VALUE）</p></li><li><p>SynchronousQueue不存储元素 , 后一个 <code>Runnable</code> 任务入队 , 必须等到前一个任务执行完毕才可以 , 否则会一直阻塞等待</p></li><li><p>PriorityBlockingQueue: 有优先级的阻塞队列 无界，生产者不会被阻塞，而消费者可能被阻塞，所以要保证消费速度更快。</p></li><li><p>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到<br> 该元素。没有大小限制，生产者不会被阻塞，只有消费者可能会阻塞。</p></li></ol><ul><li>等待时间</li></ul><p>当线程超过该时间就会被销毁，也就是说线程不会一直存在与线程池中的，销毁操作的前提是线程数大于核心线程数</p><ul><li>拒绝策略</li></ul><p>达到了最大线程数无法创建新的线程而且阻塞队列也满了，这时候如果提交任务就会执行拒绝策略，拒绝策略有四种</p><ol><li><p>AbortPolicy ：直接抛出异常 rejectedExecutionException</p></li><li><p>DiscardPolicy ： 将当前任务丢弃 不抛出异常</p></li><li><p>DiscardOldestPolicy ： 将最前面的任务丢弃 然后重新提交该任务</p></li><li><p>CallRunsPolicy ： 由调用线程去执行该任务</p></li></ol><p>AbortPolicy是默认的拒绝策略，大多数情况下我们都希望在系统达到峰值的时候系统无法处理当前任务及时抛出异常，被我们所捕获。</p><p>而丢弃策略则是对于一些不太重要的业务，至于是否重要就要自行评估了。丢弃最早的任务说明该线程池中的线程是有时间优先度的。后面的任务比前面的任务更重要。最后一种策略的话 是你不想丢弃任何一个任务也不想要抛出异常，</p>`,24),p=[o];function r(n,c){return l(),t("div",null,p)}const u=e(a,[["render",r],["__file","Thread-Pool.html.vue"]]),m=JSON.parse('{"path":"/java/Java-Advanced/Thread-Pool.html","title":"线程池","lang":"zh-CN","frontmatter":{"title":"线程池","date":"2024-05-29T00:00:00.000Z","article":false,"order":3,"description":"什么是线程池 线程池是对于线程而言的一种池化技术，通过线程池实现了对线程的管理，避免频繁创建和销毁线程导致的损耗。本来正常应该销毁的线程因为线程池这个技术现在不会直接销毁，可能会等待一段时间又去完成一个新的任务，这样达到了线程复用，过程中该线程仅仅是等待了一段时间，状态进行了相关的变化而已。 如果用过JVM调优，应该看到过当我们启用JVM之后是可以看到...","head":[["meta",{"property":"og:url","content":"https://lianyp.fun/lyp-blog/java/Java-Advanced/Thread-Pool.html"}],["meta",{"property":"og:site_name","content":"小道空间-Vuepress开源轻博客系统"}],["meta",{"property":"og:title","content":"线程池"}],["meta",{"property":"og:description","content":"什么是线程池 线程池是对于线程而言的一种池化技术，通过线程池实现了对线程的管理，避免频繁创建和销毁线程导致的损耗。本来正常应该销毁的线程因为线程池这个技术现在不会直接销毁，可能会等待一段时间又去完成一个新的任务，这样达到了线程复用，过程中该线程仅仅是等待了一段时间，状态进行了相关的变化而已。 如果用过JVM调优，应该看到过当我们启用JVM之后是可以看到..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-29T08:03:02.000Z"}],["meta",{"property":"article:author","content":"梁小道"}],["meta",{"property":"article:published_time","content":"2024-05-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-29T08:03:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"线程池\\",\\"description\\":\\"什么是线程池 线程池是对于线程而言的一种池化技术，通过线程池实现了对线程的管理，避免频繁创建和销毁线程导致的损耗。本来正常应该销毁的线程因为线程池这个技术现在不会直接销毁，可能会等待一段时间又去完成一个新的任务，这样达到了线程复用，过程中该线程仅仅是等待了一段时间，状态进行了相关的变化而已。 如果用过JVM调优，应该看到过当我们启用JVM之后是可以看到...\\"}"]]},"headers":[{"level":2,"title":"什么是线程池","slug":"什么是线程池","link":"#什么是线程池","children":[{"level":3,"title":"线程池的使用","slug":"线程池的使用","link":"#线程池的使用","children":[]}]}],"git":{"createdTime":1716969782000,"updatedTime":1716969782000,"contributors":[{"name":"liangyp","email":"2267841523@qq.com","commits":1}]},"readingTime":{"minutes":3.44,"words":1033},"filePathRelative":"java/Java-Advanced/Thread-Pool.md","localizedDate":"2024年5月29日","excerpt":"<h2>什么是线程池</h2>\\n<p>线程池是对于线程而言的一种池化技术，通过线程池实现了对线程的管理，避免频繁创建和销毁线程导致的损耗。本来正常应该销毁的线程因为线程池这个技术现在不会直接销毁，可能会等待一段时间又去完成一个新的任务，这样达到了线程复用，过程中该线程仅仅是等待了一段时间，状态进行了相关的变化而已。</p>\\n<p>如果用过JVM调优，应该看到过当我们启用JVM之后是可以看到程序当前使用的线程数量的，而对于系统来说线程也是需要耗费资源的，线程的创建和销毁涉及到操作系统底层到用户层的切换，所以属于一个偏重的操作。很多任务执行过程特别短，但是呢，数量多，这时候通过线程池就是非常合适的。</p>","autoDesc":true}');export{u as comp,m as data};
